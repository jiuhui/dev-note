## 类加载（class loading）

在java代码中，类的加载、连接与初始化的过程都是在程序的运行期间完成的

在程序运行期间完成类的加载、连接和初始化为Java代码提供了更大的灵活性，增加了更多的可能性。比如Java的动态代理，在类加载之后才会生成动态代理类。

<!--这里的类型指的是java类、interface等，并不是指java的对象。-->

- 加载 ：查找并加载类的二进制数据

- 连接 ：

  - 验证：确保被加载的类的正确性

  - 准备：为类的静态变量分配内存，并将其初始化为默认值

  - 解析：把类中的符号引用转换为直接引用

    - 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在[Java](http://lib.csdn.net/base/javaee)中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

    - 直接引用：直接引用可以是

      （1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）

      （2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）

      （3）一个能间接定位到目标的句柄

      直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。

- 初始化：为类的静态变量赋予正确的初始值



```java
class Test{
    public static int i = 1;
}
1、加载Test类的二进制文件到内存
2、验证正确 为i分配内存，赋值为0，//初始为默认值
3、为i赋值
```





## 类加载器

<!--类加载器用来加载类到内存中-->

Java虚拟机与程序的生命周期

- 在如下几种情况下，Java虚拟机将结束生命周期
  - 执行了System.exit()方法
  - 程序正常执行结束
  - 程序在执行过程中遇到异常或者错误而异常终止
  - 由于操作系统出现错误而导致Java虚拟机进程终止

