# 解决线程安全问题



### 1、为什么会出现线程安全问题？

​	线程安全其实也可以叫内存安全。因为目前主流的操作系统都是多任务的，即多个任务同时进行，为了保证安全，
每个进程只能访问分配给自己的内存空间，而不能访问别的进程的内存空间，这是由操作系统来保证的。在每个进程的内
存空间中都会有一块特殊的公共区域，通常称为堆（内存）。进程内的所有线程都可以访问到该区域，这就是造成线程不
安全的潜在原因，所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外
修改的风险。

### 2、把数据放在栈内存避免线程安全问题

如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中。较为常见的就是局部变量。
也就是说这些局部变量会在每个线程的栈内存中都分配一份。由于线程的栈内存只能自己访问，所以栈内存中的变量只属于自己，其它线程根本就不知道。
这中方法就是把数据放在一个安全位置去解决线程安全问题的。

### 3、通过ThreadLocal使得每个线程在堆内存中都有自己的一份数据

要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这不就安全了嘛，
线程类（Thread）有一个成员变量，类似于Map类型的，专门用于存储ThreadLocal类型的数据。从逻辑从属关系来讲，
这些ThreadLocal数据是属于Thread类的成员变量级别的。从所在“位置”的角度来讲，这些ThreadLocal数据是分配在公共区域的堆内存中的。
说的直白一些，就是把堆内存中的一个数据复制N份，每个线程认领1份，同时规定好，每个线程只能玩自己的那份，不准影响别人的。

其实就像大街上的共享单车。原来只有1辆，大家抢着骑，老出问题。现在从这1辆复制出N辆，每人1辆，各骑各的，问题得解。
共享单车就是数据，你就是线程。骑行期间，这辆单车从逻辑上来讲是属于你的，从所在位置上来讲还是在大街上这个公共区域的，
因为你发现每个小区大门口都贴着“共享单车，禁止入门”。

### 4、定义只读变量

只能读取，不能修改。其实就是常量或只读变量，它们对于多线程是安全的，想改也改不了  final double passScore = 60;

> 上面的三种方法，其实都是在“耍花招”。
>

### 5、通过互斥锁来解决。

如果很多个线程操作同一个数据，那么可以用互斥锁来解决，先来的线程先获取锁，操作完释放锁，其他线程再去竞争锁。
其实就是悲观锁。



```java
class ClassAssistant {
    double totalScore = 60;
    final Lock lock = new Lock();
	public void addScore(double score) {
    lock.obtain();
    totalScore += score;
    lock.release();
}
```
}

### 6、通过乐观锁解决

2个线程操作同一个数据和200个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，
线程越少数据不安全的概率越小。取个极限情况，那就是只有1个线程，那不安全概率就是0，也就是安全的。如果在线程数目特别少的时候，
可能根本就不会有别的线程来操作数据，此时你还要获取锁和释放锁，可以说是一种浪费。针对这种“地广人稀”的情况，专门提出了一种方法，
叫CAS（Compare And Swap）。就是在并发很小的情况下，数据被意外修改的概率很低，但是又存在这种可能性，此时就用CAS。这里的CAS其实就是乐观锁