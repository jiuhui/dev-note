# 数据库脏读、不可重复读、幻读

假设我们现在有这样一张表（T），里面记录了很多牛人的名字，我们不进行事务的隔离看看会发生什么呢？

## 脏读（就是读取了事务没提交的数据）

事务A访问了数据库，它干了一件事情，往数据库里加上了新来的牛人的名字，但是没有提交事务。

insert into T values (4, '牛D');

这时，来了另一个事务B，他要查询所有牛人的名字。

select Name from T;

这时，如果没有事务之间没有有效隔离，那么事务B返回的结果中就会出现“牛D”的名字。这就是“脏读（dirty read）”。

## 不可重复读（前后查询的结果不一样或者说重复读取的结果不一样）

事务A访问了数据库，他要查看ID是1的牛人的名字，于是执行了

select Name from T where ID = 1;

这时，事务B来了，因为ID是1的牛人改名字了，所以要更新一下，然后提交了事务。

update T set Name = '不牛' where ID = 1;

接着，事务A还想再看看ID是1的牛人的名字，于是又执行了

select Name from T where ID = 1;

结果，两次读出来的ID是1的牛人名字竟然不相同，这就是不可重复读（unrepeatable read）。

## 幻读

事务A访问了数据库，他想要看看数据库的牛人都有哪些，于是执行了

select * from T;

这时候，事务B来了，往数据库加入了一个新的牛人。

insert into T values(4, '牛D');

这时候，事务A忘了刚才的牛人都有哪些了，于是又执行了。

select * from T;

结果，第一次有三个牛人，第二次有四个牛人。

相信这个时候事务A就蒙了，刚才发生了什么？这种情况就叫“幻读（phantom problem）”。